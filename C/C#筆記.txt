===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
1.為甚麼，class Program，主程式會知道要跑這個?
2. static void Main() 他是如何呼叫的?
ChatGPT 說：

非常棒的問題！👏
這兩個問題都切中 C# 執行架構 的核心。讓我們一步步拆解。

🧩 問題 1：為什麼主程式會知道要跑 class Program？

其實，主程式不是特別去找「Program」這個類別名稱。
它在找的是：👉 有沒有包含 Main() 方法的類別。

在 C# 中：

程式執行的起點是「Main 方法（Main entry point）」，

而不是特定叫做 Program 的類別。

🔍 說明：

你可以有不同名字的類別，只要其中有 Main() 方法，程式都能從那裡開始：

using System;

class MyApp
{
    static void Main()
    {
        Console.WriteLine("這個程式從 MyApp.Main() 開始執行");
    }
}


執行結果會一樣，因為：

編譯器會搜尋整個專案中「哪個類別」包含 static void Main()，然後從那裡開始。

⚙️ 技術細節：

在編譯時（build 時期），C# 編譯器會建立一個可執行檔（.exe）。
這個檔案的中繼資料（metadata）會記錄哪個方法是「入口點（entry point）」。

💡 所以「Program」只是慣例名稱，不是規定。
Visual Studio 建新專案時，預設給你一個 Program.cs，只是為了方便人類閱讀。

⚙️ 問題 2：static void Main() 是如何被呼叫的？

這個問題很深、問得非常好。
我們來從底層流程理解 👇

🔸 執行流程：

你按下「執行」或在命令列輸入：

dotnet run


.NET 執行階段（CLR：Common Language Runtime）啟動。

CLR 載入你的程式組件（Assembly，通常是 .exe）。

CLR 檢查組件中哪個方法是「entry point」（入口點），通常就是：

static void Main()


CLR 呼叫它，程式正式開始執行。

🔹 為什麼要加 static？

因為：

在程式啟動時，CLR 還沒有建立任何物件。

static 代表「屬於類別本身」，不用先建立物件就能呼叫。

所以，CLR 可以直接呼叫：

Program.Main();


而不用先：

var p = new Program();
p.Main(); // ❌ 不行，因為那需要物件

🔹 為什麼回傳型別是 void？

因為大部分程式不需要回傳值。
但如果你想讓程式回傳「結束狀態碼（exit code）」給系統，也可以寫成：

static int Main()
{
    Console.WriteLine("程式執行完畢");
    return 0; // 0 通常代表成功
}

🔹 為什麼要用 Main 這個名字？

這是 .NET 的語言規範 所定義的「保留名稱」。
CLR 會特別尋找名字叫 Main 的方法作為入口點。
你不能用其他名字（像是 Start 或 Run）取代它，否則程式不知道從哪裡開始。

🧠 小總結
概念	說明
Program 類別	名字隨意，慣例名稱而已。
Main() 方法	程式的「入口點」。CLR 從這裡開始執行。
static	讓 CLR 不需建立物件就能直接呼叫。
void / int	可選擇是否要回傳結束狀態碼。

是否希望我下一步帶你看「變數（Variables）」與「資料型別（Data Types）」的概念？
那是理解 Main() 之後最自然的下一課。

你說：
那如果我有兩隻class，期都有 main呢? 那如何判斷會執行哪一隻?
ChatGPT 說：

超級好問題 👍👏！
這其實是 C# 編譯器與專案設定 的關鍵機制之一。
你問的狀況確實會發生在大型專案裡 —— 當不同類別都有 Main() 方法時，程式該從哪個開始？

🧩 情境範例

假設你有兩個類別檔案：

📄 ProgramA.cs
using System;

class ProgramA
{
    static void Main()
    {
        Console.WriteLine("這是 ProgramA 的 Main()");
    }
}

📄 ProgramB.cs
using System;

class ProgramB
{
    static void Main()
    {
        Console.WriteLine("這是 ProgramB 的 Main()");
    }
}


這樣的程式能不能編譯？
答案是：可以，但你必須指定哪一個是「入口點（entry point）」。

🧠 原理說明

在 C# 中，整個應用程式只能有一個 entry point（Main 方法）。
如果有多個 Main()，編譯器會報錯：

Program has more than one entry point defined.
Compile with /main to specify the type that contains the entry point.


這句英文的意思是：

你有多個 Main()，請使用 /main 編譯選項或在專案設定中指定哪一個是主入口。

⚙️ 解決方式一：Visual Studio 專案設定

如果你是用 Visual Studio，可以這樣做：

右鍵點擊專案 → 選擇 屬性 (Properties)

選取左側的 應用程式 (Application)

在「啟動物件 (Startup object)」下拉選單中，
選擇你要執行的類別（例如 ProgramA 或 ProgramB）

💡 這樣你就能決定執行哪一個 Main。

⚙️ 解決方式二：使用編譯參數（命令列）

如果你是用命令列（例如 dotnet build 或 csc）編譯：

csc /main:ProgramB ProgramA.cs ProgramB.cs


這表示：

用 ProgramB.Main() 作為程式的入口。

⚙️ 解決方式三：用不同專案管理不同入口

在實務上，一個專案通常只會有一個 Main()。
但你可以用「多專案方案（multi-project solution）」的方式：

每個專案各自有一個 Main()；

在 Visual Studio 裡設定「哪個專案是啟動專案」。

例如：

MySolution/
 ├─ ProjectA/ (有 ProgramA.Main)
 ├─ ProjectB/ (有 ProgramB.Main)


然後在方案中設定要執行哪一個。

🧩 小結表
狀況	結果
只有一個 Main	自動執行那一個
有兩個以上 Main	編譯失敗，需指定啟動物件
用 Visual Studio	可在「屬性 → 應用程式 → 啟動物件」選擇
用命令列	可用 /main:<ClassName> 指定
多專案方案	各自有 Main，可選擇哪個專案執行

💬 小延伸：
這個設計其實反映 C# 的「明確性原則」：

不讓系統「猜」哪個 Main 才是正確的，而是要開發者明確指定。
===================================================================
IEnumerable<T> 就是 一個能逐一列舉元素的集合介面，適合用來做「回傳資料」時的標準型別，因為它很通用，不綁死具體實作。
===================================================================
1. Package Manager Console 是什麼

Package Manager Console 是 Visual Studio 內建的一個 PowerShell 視窗。

主要用來透過命令行操作 NuGet 套件管理器 (NuGet Package Manager)。

換句話說，它是 Visual Studio 的命令列版 NuGet 工具。

2. 它的用途

你可以在 Package Manager Console 直接輸入 NuGet 指令來：

安裝套件

Install-Package Newtonsoft.Json


更新套件

Update-Package Newtonsoft.Json


移除套件

Uninstall-Package Newtonsoft.Json


查詢套件資訊

Get-Package


這些指令背後做的事情，就是修改你專案裡的：

packages.config 或 *.csproj 檔案（記錄套件相依性）

下載實際的 DLL / 套件檔案到專案中
===================================================================
C# 的 Stack<T>
這個是 .NET 提供的泛型資料結構。
就像我前面說的，一疊盤子 🍽️，提供 Push() 跟 Pop() 這些方法，方便程式設計師存取資料。
它只是 程式碼層級的容器 (Container)，存在於記憶體的「堆 (Heap)」裡。
你可以隨時 new 一個 Stack<T>，放你想要的型別。
✅ 總結：C# 的 Stack<T> 只是個「工具」，讓你用後進先出的方式存東西。

電腦的 CPU Stack（呼叫堆疊，Call Stack）
這個是 電腦硬體/作業系統本身就有的記憶體區域。
當程式呼叫一個方法 (function) 時，電腦會把：
參數
區域變數
返回位址 (return address)
這些資料「壓進」CPU 的 Stack（Push）。
當方法執行完，電腦會從 Stack 取出(return address)，跳回呼叫的地方（Pop）。
這樣才能正確回到上一層程式。
✅ 總結：電腦的 Stack 是 CPU 在跑程式時必須用的記憶體結構，和語言有關但不是 C# 特有。
===================================================================
1. 泛型的「算法」其實不是演算法，而是底層機制
泛型本身不是一個排序或加密那種「算法」，它是 編譯時幫你做型別替換的機制。

如果你寫 List<string>，就會生成一個「專門給 string 用的 List 類別」。
這種做法叫 編譯時型別綁定 (compile-time type binding)。
===================================================================
1. 泛型是什麼？
泛型就是一種 在宣告類別、介面或方法時，先不指定具體資料型別，而是使用型別參數 (Type Parameter)，等到實際使用時再指定具體型別的程式設計方式。

📌 換句話說：
泛型 = 「型別的模板」
它讓你能在程式裡寫 一次邏輯，支援多種型別，而不需要重複寫程式碼。

📌 小結
泛型 = 可以裝任何東西的「空盒子」
好處 = 省程式碼、放什麼都安全、用起來方便
===================================================================
CPU 的線程（Thread）
. 多核心 CPU
現代 CPU 不是只有「一個大腦」，而是有多個「核心 (Core)」：
單核心：一次只能處理一個任務。
多核心：可以同時處理多個任務（平行運算）。
例：四核心 CPU 就像有 4 個小腦袋，每個能同時跑程式。

. 超執行緒 (Hyper-Threading)
Intel 很常講的 Hyper-Threading，就是 模擬一個核心像兩個邏輯核心。
硬體上還是 1 個核心。
但對作業系統看起來像 2 個核心，可以同時處理兩條指令流程（效率不會翻倍，大概提升 20-30%）。

執行緒 (Thread)
執行緒是程序裡的最小執行單位。
一個程序可以有一個或多個執行緒：
單執行緒：一次只能做一件事。
多執行緒：同一個程式裡的不同工作可以「看似」同時進行。

例：Chrome
主執行緒：負責顯示介面
一個執行緒：下載檔案
一個執行緒：播放音樂
👉 所以「執行緒」就是 CPU 能直接排程、執行的工作單位。

CPU 與執行緒的對應關係
單核心 CPU：同一時間「真的」只能執行一個執行緒。
（多任務其實是「快速切換」產生的錯覺）
多核心 CPU：每個核心可以同時執行一個執行緒。
超執行緒 (Hyper-Threading)：
一個核心可模擬同時執行兩個執行緒 → 對作業系統來說就是「雙倍核心」。

CPU 是「做工的工人」
執行緒 是「工人要做的任務」
多核心/超執行緒 讓 CPU 能同時做更多任務，而不只是快速切換。

C#（.NET）本身就有提供 多執行緒 (multithreading) 的功能，而且有好幾種不同層級的 API 可以用。

C# 後來引入 Task 平行程式庫 (TPL)，比 Thread/ThreadPool 更方便，支援 非同步/await：
===================================================================
🔹 1. 耦合（Coupling）是什麼？
定義：耦合指的是 兩個模組或類別之間的依賴程度。
換句話說，就是「A 模組改變了，B 模組會受到多大影響？」

🔹 2. 耦合的類型
耦合可以分成低耦合 (Loose Coupling) 和 高耦合 (Tight Coupling)

為甚麼街口interface，可以有效降低耦合? 對，這個點抓得很精準 👍
介面（interface）在 C# 裡是降低耦合的核心工具，原因可以從幾個角度理解：
🔹 1. 介面的本質
介面只定義 行為契約 (Contract)，不包含實作細節。
任何類別只要「遵守這個契約」就可以被替換。
這意味著：程式碼不依賴具體類別，而依賴抽象。

3. 總結
介面 = 行為契約，程式只依賴「契約」，不依賴具體實作
透過介面：
不同實作可以互換 → 支援多型
修改實作不影響使用它的程式 → 降低耦合
測試時可用假物件 → 測試方便

💡 簡單比喻：
介面像是插座，你只知道它能提供電（Start 方法）
不同引擎類別像是不同的電器，插進去就能工作
Car 不需要知道是哪種電器 → 耦合降低
===================================================================
里氏替換原則 (LSP) 是什麼？
定義：
如果 S 是 T 的子類別，則在程式中出現型別 T 的地方，都可以用 S 來替換，而不會影響程式的正確性。
換句話說：子類別必須能夠完全替代父類別，而不會破壞原本的功能。

符合 LSP → 程式設計時，父類別與子類別能安全互換，提高可擴展性與維護性。
違反 LSP → 你以為在用父類別，結果子類別壞掉，導致程式不穩定。

✅ 總結
里氏替換原則（LSP）= 子類別必須能替換父類別而不破壞正確性。
核心精神：「不要讓子類別違背父類別的承諾」。
如果違反了，應該重新抽象化父類別設計。
===================================================================
當你在 IDE「添加引用」的時候，背後其實做了這些事：
改 .csproj → 增加 <ProjectReference> 或 <Reference>
編譯時 → 幫 csc 加上 /reference:xxx.dll
複製 DLL 到 bin\ 輸出資料夾
提供 IntelliSense 型別資訊

那其實，我可以直接在 .csproj 加引用的CODE，然後BUILD，專案會自己幫我開始引用了?
完全正確 ✅
你完全可以不透過 IDE 的「右鍵 → Add Reference」，而是直接打開 .csproj 去寫引用，然後按 Build，專案就會自動開始引用。
這就是 Visual Studio 在背後做的事。

NuGet 是 .NET 平台的套件管理工具，就像 Node.js 的 npm 或 Python 的 pip 一樣。
它讓你可以很方便地下載、安裝、更新、管理別人寫好的 程式庫 (Library/DLL)。

範例 3：NuGet 套件引用
其實 NuGet 也是類似原理，只是 .csproj 用 <PackageReference>：
<ItemGroup>
  <PackageReference Include="Newtonsoft.Json" Version="13.0.1" />
</ItemGroup>
Build 時，MSBuild 會自動去下載對應的 DLL，放到專案依賴裡。
===================================================================
3. 編譯時 vs 執行時
編譯時引用 (Add Reference / /reference)
→ 編譯器會檢查型別安全、幫你補 IntelliSense。

執行時引用 (Assembly.Load)
→ 靈活，但編譯器不知道類別存在，失去了型別檢查，需要靠反射操作。
===================================================================
🔹 2. 執行時 (Runtime)：動態載入 DLL
如果你想在程式執行的時候 動態引用 DLL，可以用反射 (Reflection) 或 Assembly.Load：

範例：動態載入 DLL
using System;
using System.Reflection;
class Program
{
    static void Main()
    {
        // 動態載入 ProjectA.dll
        Assembly asm = Assembly.LoadFrom("ProjectA.dll");

        // 找到類別 ProjectA.PublicClass
        Type t = asm.GetType("ProjectA.PublicClass");

        // 建立實例
        object obj = Activator.CreateInstance(t);

        // 呼叫方法 Hello()
        MethodInfo method = t.GetMethod("Hello");
        method.Invoke(obj, null);
    }
}

👉 這種方法在 Plugin 架構 很常見，例如你讓程式支援外掛，外掛是 DLL，執行時才載入。
===================================================================
一般我們在 Visual Studio 裡都是用「右鍵 → 添加參考 (Add Reference)」去做，但其實底層就是在告訴 編譯器：「這個程式要依賴某個 DLL」。
你問「能不能用 code 做」，答案是：可以，但方式不同，要看你要的情境。

如果你不用 IDE，而是用 命令列編譯器 csc，你可以手動指定引用的 DLL，例如：
csc /reference:ProjectA.dll Program.cs
這樣 Program.cs 裡的程式碼就能用 ProjectA.dll 裡的 public 類別。
👉 這相當於 Visual Studio 的「添加專案引用」。

🔹 2. 執行時 (Runtime)：動態載入 DLL
如果你想在程式執行的時候 動態引用 DLL，可以用反射 (Reflection) 或 Assembly.Load：
===================================================================
很多人一開始會以為 using 就能「導入」別的專案的程式碼，但其實 using 和 引用 是完全不同層次的東西。
🔹 1. using 是什麼？
using 只是一個 語法糖，讓你不用每次都寫完整名稱空間 (namespace)。
它 不會幫你建立引用關係。

例如：
using System.Text;
class Program
{
    static void Main()
    {
        StringBuilder sb = new StringBuilder(); // 因為有 using，所以不用寫 System.Text.StringBuilder
    }
}

👉 如果少了 using，你還是可以寫：
System.Text.StringBuilder sb = new System.Text.StringBuilder();

2. 沒有「添加引用」會發生什麼？
如果你在 ProjectB 裡只寫：
using ProjectA;
但 沒有添加 ProjectA 的專案引用，編譯器會直接報錯：
The type or namespace name 'ProjectA' could not be found
因為編譯器根本找不到 ProjectA.dll，它不知道這個 namespace 代表什麼。

3. 比喻
引用 (Reference) → 像是你「裝了這本書」。
using → 像是「翻到這本書的目錄，快速跳到你要的章節」。

✅ 總結：
一定要添加引用（不論是專案引用或 DLL 引用），才能使用別的專案的程式碼。
using 只是語法輔助，讓程式碼更好讀，不會替你解決引用問題
===================================================================
你前面問到 internal，剛好跟「專案引用」有關，我幫你從 C# 專案 (Project) 與 組件 (Assembly) 的角度解釋。
🔹 1. 專案 (Project) 與 組件 (Assembly)
在 Visual Studio / .NET 專案裡，每個 Project 編譯後，通常會產生一個 組件 (Assembly)，就是一個 .dll 或 .exe。

例如：
ProjectA → 編譯後得到 ProjectA.dll
ProjectB → 編譯後得到 ProjectB.exe

添加專案引用就是讓 A 專案能用 B 專案的公開成員 (public)。
internal 修飾的東西，即使有引用，也不能跨專案存取。
引用有兩種：專案引用（開發階段方便同步更新）、DLL 引用（直接用已編譯的組件）。
===================================================================
存取修飾詞（Access Modifiers）
1. public
意思：完全公開，任何地方都可以存取。
使用情境：API 或類別需要對外提供功能。

2. private
意思：只有在 類別內部 才能存取。
使用情境：封裝（Encapsulation），避免外部程式任意修改內部狀態。

3. protected
意思：只有 類別本身 和 子類別 (繼承它的 class) 可以存取。
使用情境：希望子類別能用，但不想完全對外公開。

4. internal
意思：僅限 同一個組件 (Assembly) 中的程式可以存取。
（通常一個專案編譯後是一個 Assembly，例如 .dll 或 .exe）
使用情境：提供模組內部使用的功能，但不想讓外部專案存取。
===================================================================
1. 擴充方法 (Extension Method) 是什麼？

擴充方法就是 在不改變原本類別的情況下，替它新增方法。
也就是說，你可以「擴充」現有的 class、struct 或 interface 的功能。

public static string FirstUpper(this string input)
這裡的重點是：
static class：擴充方法必須放在一個靜態類別裡（例如 Tool）
static 方法：方法本身必須是靜態的
this 參數：this string input 表示這個方法是 針對 string 類別的擴充
===================================================================
靜態類的生命週期
靜態類 不會被 GC 回收，因為它本質上只是 型別 (Type) 的 metadata + 一份 靜態欄位的儲存區。
這些資訊一旦載入，就會一直存活到 AppDomain 卸載 (Unload) 為止。
===================================================================
物件的生命週期
C# 的 CLR（Common Language Runtime） 機制
1. CLR 是什麼？
CLR = Common Language Runtime（共通語言執行環境）
是 .NET Framework / .NET Core / .NET 5+ 的核心執行引擎。
功能就像 一個虛擬機器（VM）+ 執行管理系統，負責執行 C# 程式碼，管理記憶體、型別安全、例外處理、垃圾回收等等。
簡單比喻：CLR 就像「程式的後勤部隊」，幫你管理記憶體、資源和安全，程式不用自己操心細節。

CLR 幫你管理：
記憶體：stack / heap、GC 回收
型別安全：防止非法存取
例外處理
多執行緒
安全性檢查

3. CLR 管理的資源
功能	說明
Garbage Collection (GC)	自動回收 heap 上的物件，不用手動 free/delete
Stack / Heap 管理	分配 stack frame、物件在 heap 上的位置
型別檢查	保證程式不會存取錯誤型別的記憶體
JIT 編譯	IL → 原生機器碼
安全性檢查	防止程式操作危險指標或非法操作
===================================================================
using System;

class MyClass
{
    // 四個 int 欄位
    public int a;
    public int b;
    public int c;
    public int d;

    // 建構子，用來初始化欄位
    public MyClass(int a, int b, int c, int d)
    {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
    }

    // 方法：計算四個數字的總和
    public int Sum()
    {
        return a + b + c + d;
    }
}

class Program
{
    static void Main()
    {
        // 建立類別物件
        MyClass obj = new MyClass(1, 2, 3, 4);

        // 使用類別的方法
        Console.WriteLine("Sum = " + obj.Sum());  // 輸出 Sum = 10

        // 直接修改欄位
        obj.a = 10;
        Console.WriteLine("New Sum = " + obj.Sum()); // 輸出 New Sum = 19
    }
}

為甚麼 return a + b + c + d; 這邊的a,b,c... 他會直接認得是class的，而不需要 this.a + this.b...

1. 為什麼可以直接用 a 而不是 this.a
在 C# 裡，如果你在 類別的方法內使用變數名稱，編譯器會按照 以下順序找變數：
方法的區域變數（local variable）
例如 int x = 5; 在方法裡宣告的變數。
方法的參數（parameters）
例如 public void Foo(int x)，x 優先於欄位。
類別的欄位（field）
如果在方法裡找不到 local 變數或參數，會使用類別裡的欄位。
這就是為什麼你可以直接寫：
return a + b + c + d;
編譯器知道 a,b,c,d 是這個類別的欄位。

2. 什麼時候需要用 this.
當 區域變數或參數的名稱與欄位名稱衝突 時，需要用 this 來明確指欄位。
class MyClass
{
    public int a;

    public void SetValue(int a)  // 參數 a 與欄位 a 同名
    {
        a = a;        // ❌ 只改了參數 a，不改欄位
        this.a = a;   // ✅ 明確改欄位 a
    }
}
如果沒有命名衝突，this. 可以省略，C# 會自動解析到欄位。

🔑 小結
沒有衝突 → 可以直接用欄位名稱。
有衝突 → 用 this. 指明是類別欄位。
this 本質上是一個指向 當前物件的參考，在 instance 方法裡隱含存在。
===================================================================
| 特性       	| class（類別）              	| struct（結構體）             
| --------------| --------------------------| ----------------------- 
| 型別       	| 參考型別（Reference Type）  | 值型別（Value Type）         
| 記憶體配置    	| Heap（物件本體在堆上）       | Stack（局部變數在棧上）或內嵌在其他物件中 
| 預設建構子    	| 可以有自訂建構子       		| 沒有無參數建構子（系統自帶預設建構子）     
| 繼承       	| 可以繼承其他類（單一繼承）    	| 不支援繼承（可以實作介面）           
| 釋放記憶體    	| 由 GC（垃圾回收）管理        | 自動隨變數作用域消失              
| 可否為 null 	| 可以，因為是 reference type	| 不可以（值型別）                
===================================================================
物件: 封裝，繼承，多態
===================================================================
在 C# 中，out 和 ref 都是 參考傳遞（pass by reference） 的方式，但它們有一些重要差異。
ref → 已有值，要讓方法修改它。
out → 沒有值，要讓方法提供一個輸出。
===================================================================
out: 可使用便量的地址，而非拷貝
===================================================================
📌 Heap 的釋放時機
這就依語言不同而不同了：

在 C# / Java / Python（有 Garbage Collector, GC）
Heap 上的物件不需要手動釋放。
GC 會自動偵測「不再被任何變數參考的物件」，然後釋放它們。
所以 heap 的釋放時機是 GC 覺得需要回收時（不一定馬上）。
當程式結束時，作業系統一樣會回收整個 process 的記憶體。
===================================================================
📌 Stack 的釋放時機
每個函式呼叫都會在 Stack 上開一塊「stack frame」（儲存區域）。
當函式執行結束，這個 stack frame 自動釋放。
不用程式設計師管，由編譯器/系統自動處理。

👉 範例：
void foo() {
    int x = 10;   // x 在 stack 上
}  // foo 結束 → x 自動消失
===================================================================
1. string 的型別
string fruit = "apple";
fruit 本身是一個變數（存在 stack 上），裡面存的是一個 參考（reference）。
這個參考指向 heap 上的字串物件 "apple"。

2. 不可變性（Immutable）
字串內容一旦建立就不能改變。
當你「改字串」的時候，其實是 建立一個新字串物件，再讓參考指向它。

👉 範例：
string fruit = "apple";
fruit = fruit.ToUpper();   // 不是把 "apple" 變成 "APPLE"
                          // 而是建立一個新的 "APPLE"
Console.WriteLine(fruit); // 輸出 "APPLE"
這裡 "apple" 還在 heap 裡，只是 fruit 變數改指向新的 "APPLE"。

3. 跟陣列（int[]）的差別
陣列 (int[]) 也是 reference type，但它是 可變的（mutable） → 你可以直接改裡面的元素。
字串 (string) 雖然也是 reference type，但它是 不可變的（immutable） → 每次修改都會產生新物件。
===================================================================
static void Main()
{
    int[] arr = { 1, 2, 3, 4, 5 };
    upateArray(arr);
    Console.WriteLine(string.Join(", ", arr));
}

static void upateArray(int[] arr)
{
    for (int i = 0; i < arr.Length; i++)
    {
        arr[i] += 5;
    }
}
為甚麼 arr 改變了?

因為 在 C# 中，陣列是「參考型別（reference type）」。
宣告 int[] arr = { 1, 2, 3, 4, 5 };
Stack：變數 arr（reference，參考）
Heap：真正的陣列物件 [1, 2, 3, 4, 5]

當你呼叫 upateArray(arr)：
參數 arr 傳遞的不是整個陣列的拷貝，而是那個 heap 陣列的「參考」。
所以 upateArray 裡修改 arr[i]，其實就是在改 heap 裡的那個陣列本體。
===================================================================
為什麼需要 Heap
Stack 適合：小型、暫時、作用域清楚的資料。
Heap 適合：大型、動態、跨作用域存活、需要彈性的資料。

⚡一句話：
Stack 是暫存桌子，Heap 是倉庫。
桌子（Stack）上東西拿取快，但空間有限；
倉庫（Heap）空間大、能存久，但要自己整理，動作也比較慢。
===================================================================
struct 是 值型別，用來表示小型、不可變或簡單的資料集合。
class 是 參考型別，適合複雜邏輯、需要繼承、多型的物件導向設計。

class（類別） → 參考型別 (Reference Type)
建立物件時，會放在 Heap（堆積記憶體）。
變數本身存的是「參考 (Reference)」，指向 Heap 的物件。
class Person { public string Name; }
Person p1 = new Person(); // p1 在 Stack，物件在 Heap


struct（結構體） → 值型別 (Value Type)
建立變數時，資料會直接存在 Stack（堆疊記憶體）（或內嵌在其他物件裡）。
複製變數時，會複製整份資料。

棧Stack = 書疊在桌上，你只拿最上面那本 → 速度快、規矩多
堆Heap = 倉庫的大箱子，你可以放任何東西，但找起來比較慢 → 空間大、靈活，但要有人整理

4️⃣ 在 C# 裡的應用
int a = 10; → 存在 Stack
var obj = new MyClass(); → 物件存在 Heap，obj 這個「指標」在 Stack 上

Stack 跟 Heap 都是在 RAM（隨機存取記憶體）上分配空間，只是使用方式不一樣。
差別：
特性			Stack						Heap
位置			RAM 的一小塊固定區域			RAM 的大區域，靈活分配
速度			很快（像疊書）					較慢（要找空位）
管理			自動（進入/離開函式就自動收掉）	需要程式或 GC 幫忙整理
適合存什麼	小變數、函式暫存資料			大物件、陣列、class 物件

所以它們都在記憶體裡，但Stack 是「快速、固定」，Heap 是**「大而彈性，但慢一些」**。
===================================================================
枚舉 → int：允許 (int)myEnum（因為 enum 本質就是 int）
int → 枚舉：必須 (MyEnum)myInt（強制轉型，避免誤用）

📌 例子：
OrderStatus s1 = OrderStatus.Delivered; // 枚舉
int i = (int)s1;                        // enum → int
OrderStatus s2 = (OrderStatus)i;        // int → enum
===================================================================
資料夾	內容								性質			是否要進 Git
bin/	最終輸出（.exe、.dll、pdb、config…）	編譯結果		❌ 忽略
obj/	中繼檔（obj、g.cs、assets.json…）	編譯過程暫存	❌ 忽略

👉 總結：
bin/ 是 最終產物
obj/ 是 過程中產物
兩者都不應該進 Git，只要有 .csproj 與原始碼，其他人就能重新建出來。

原始碼（.cs、.config、.resx）
⬇️ 編譯器 (csc / msbuild)
中繼檔案 → 存放在 obj/ 資料夾
⬇️ 連結 / 輸出
最終輸出 → 存放在 bin/ 資料夾
===================================================================
1. / 除法運算子
如果兩邊都是 整數 (int) → 做「整數除法」，小數點後會被捨棄。
如果其中一邊是 浮點數 (double, float) → 會做「小數除法」。

範例：
int a = 7 / 2;       // = 3   (整數除法，0.5 被捨棄)
double b = 7 / 2.0;  // = 3.5 (浮點數除法)

2. % 取餘數運算子 (modulus, modulo)
用來求「除法的餘數」。
範例：
int c = 7 % 2; // = 1   (7 ÷ 2 = 3 餘 1)
int d = 10 % 3; // = 1  (10 ÷ 3 = 3 餘 1)
===================================================================
使用一個簡單的 do while 去寫 login
public static void Main()
{
	bool result = false;
	do{
		string account = Console.ReadLine();
		string password = Console.ReadLine();
		if (account == "123" && password == "456") {
			Console.WriteLine("Login!");
			result = true;
		} else {
			Console.WriteLine("error!");
		}
	} while (result == false);
	Console.WriteLine("welcome~ welcome!");
}
===================================================================
continue: 立即結束本次循環，開始下一次循環。
===================================================================
在 C# ，switch 的 case 必須接'常量'，且最後必須 break
===================================================================
c#，int a ，string b ...，宣告後一定要給值嗎
變數類型		宣告後必須初始化嗎？	備註
-------------------------------------------------------------
局部變數		✅ 是				使用前必須賦值
成員變數		❌ 不必				有預設值，0 / null / false
靜態變數		❌ 不必				有預設值，0 / null / false
===================================================================
using System;

public class Program
{
    public static void Main()
    {
        try
        {
            string a = "123a";
            int b = int.Parse(a); // 注意 Parse 要大寫 P
        }
        catch (Exception e) // Exception 首字母大寫
        {
            Console.WriteLine(e.Message); // 印出例外訊息
        }
    }
}

1️⃣ e 本身
e 是 Exception 物件
它包含很多屬性和方法：
Message → 例外訊息字串
StackTrace → 呼叫堆疊資訊
InnerException → 內部例外
ToString() → 包含例外類型、訊息、堆疊資訊

如果你寫：Console.WriteLine(e);
實際上會呼叫 e.ToString()
===================================================================
1️⃣ int.TryParse 的行為
int.TryParse(string s, out int result) 做了兩件事：
嘗試把字串 s 轉成整數
如果成功 → result 會被設定成對應整數值，並回傳 true
如果失敗 → result 會被 設定成 0，並回傳 false
===================================================================
整數運算自動提升（integer promotion）
int a = 1;
short b = 2;
Console.WriteLine(a + b); => 3

3️⃣ 往上轉型 vs 往下轉型
轉型方向					自動 / 顯式		風險
小 → 大（short → int）	自動	安全，		無資料丟失
大 → 小（int → short）	顯式 (short)		可能溢位 / 資料丟失
===================================================================
int a = 1;
int b = 2;
Console.WriteLine( (a + b) / 2f); // 2f 強制轉型
=> 1.5
如果兩邊型別不同，C# 會自動往「不會丟失資料」的方向轉型。
常見轉換順序（由低到高）： int → float → double → decimal
===================================================================
C#邏輯口訣: 括號為優先，乘除後加減，比較後邏輯，最後左到右
&& (邏輯 AND) 比 || (邏輯 OR) 優先。 => Console.WriteLine(false || true && true); => true
===================================================================
&& 與 & ，|| 跟 | ，結果相同，但有甚麼區別?
在 C#（還有 Java、C、C++）裡，&& / || 和 & / | 看起來很像，有時候結果一樣，但其實語意不同。
&& 和 || → 邏輯運算子 (Logical operators)
& 和 | → 位元運算子 (Bitwise operators)，但在 C# 裡如果用在 bool 上，也能當 邏輯運算子。
&& 和 || 會「短路」，也就是 一旦結果已經確定，就不會繼續計算右邊
& 和 | 不會短路，兩邊一定都會執行

(B) 位元運算 (Bitwise)
& 和 | 也可以用在整數（int, byte 等），逐位元運算
&& 和 || 只能用在布林運算
int x = 6;   // 二進位 110
int y = 3;   // 二進位 011
Console.WriteLine(x & y);  // 010 → 2
Console.WriteLine(x | y);  // 111 → 7

在 C# 裡：
如果運算子兩邊是 布林值 (bool) → & / | 會被當作 邏輯運算子
如果運算子兩邊是 整數型別 (int, byte, long, …) → & / | 會被當作 位元運算子
換句話說，編譯器根據「運算元的型別」來決定意義。
===================================================================
string person = Console.ReadLine();
Console.WriteLine($"Hello, {(person == "老王" ? "你好" : "流氓")}!");
為甚麼 加了 括號 ( ... ) ，就沒事了?
在 C# 裡，字串插值 $"Hello, { ... }!" 裡面會先計算大括號 { ... } 裡面的 運算式，再把結果轉成字串。
( ... ) 明確告訴編譯器這整段是單一運算式
編譯器先計算括號裡的三元運算子：
person == "老王" ? "你好" : "流氓"
→ 結果是一個字串
然後把結果放進 $"..." 裡面 → 完全沒有歧義
===================================================================
三元運算子的語法：
condition ? value_if_true : value_if_false;
必須有回傳值
===================================================================
1. Unicode？
在電腦早期，不同國家有不同的編碼方式：
美國用 ASCII（7 bit，最多 128 個字元，只能表示英文字母、數字、符號）
台灣常用 BIG5（繁體中文）
日本用 Shift-JIS
大陸用 GB2312/GBK
問題是：👉 同一個二進位數字，在不同編碼系統裡，可能代表完全不同的字！導致「亂碼問題」。

2. Unicode 是什麼？
Unicode 就是為了解決亂碼問題而設計的： 一套 全球統一的字元編碼標準
為世界上每一個文字（不管是英文、中文、日文、韓文、emoji…）分配一個 唯一的編號 (code point)
這個編號通常寫成 U+xxxx（16 進位）

例子：
'A' → U+0041
'中' → U+4E2D
'😃' → U+1F603

3. Unicode 和 char 的關係
在 C#： char 採用 UTF-16 編碼（Unicode 的一種實作方式）
意味著一個 char 固定是 2 byte (16 bit)
可以存一個 Unicode 基本平面 (BMP, U+0000 ~ U+FFFF) 的字元
👉 但超過 U+FFFF 的字（例如 emoji）需要 兩個 char（代理對，surrogate pair） 來表示。

✅ 一句話總結
Unicode 字元就是「全世界所有文字的唯一編號」，每個字都有一個代號（U+xxxx），避免亂碼。
===================================================================
在 C# 中，一個 char 固定佔 2 個 byte (16 bit)，
用的是 UTF-16 編碼，能直接表示大多數常見的 Unicode 字元。
===================================================================
floate的精度 => 7位
小數，默認是double類型，但最常用的是floate
===================================================================
1. bit（位元）
電腦裡最小的資料單位
一個 bit 只能表示 0 或 1
例如：1011 就是 4 個 bit

2. byte（位元組）
1 byte = 8 bit
因為 8 個 bit 可以組合出 2⁸ = 256 種可能（0 ~ 255）
所以一個 byte 能表示 0～255 的數字，或者一個英文字母（ASCII 編碼）
===================================================================
多行註解（加 //） Ctrl+K, Ctrl+C => Ctrl+U(解開)
Ctrl+K => 刪掉該行
===================================================================
傳統寫法
以前寫 C# Console App，你一定要有 class 和 Main() 方法作為程式入口：
using System;
class Program
{
    static void Main(string[] args)
    {
        Console.WriteLine("Hello, World!");
    }
}
這是 完整的「傳統 C# 程式骨架」

2. 簡化寫法（C# 9 / .NET 5 之後）
從 C# 9 開始，可以省略 class Program 和 Main()，直接在檔案最上方寫程式碼：
Console.WriteLine("Hello, World!");
編譯器會自動幫你生成「隱藏的 class 與 Main()」來包住這段程式碼。
這叫 Top-level statements（頂層語句）
目的是 讓初學者更容易上手，不用先理解類別與方法。
===================================================================
C# 編譯 > IL > 打包進 .exe / .dll > 執行 > CLR參戰 > CLR載入IL 
	> JIT把IL轉成機器碼 > CPU執行機器碼
===================================================================