<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>

<body>
  <p>NODEJS，是一款應用程式，是一個軟件，可以用來運行JS。</p>
  <hr>
  <section>
    <h2>打包工具速覽</h2>
    <ol>
      <li><strong>Babel</strong> — 負責把新 JS 語法轉成舊版（功能完整，但相對較慢）。</li>
      <li><strong>esbuild</strong> — 用 Go 寫的超快速編譯與打包器，速度非常快但功能較簡潔。</li>
      <li><strong>Webpack</strong> — 萬能但笨重的傳統打包器，擴充套件眾多。</li>
      <li><strong>Rollup</strong> — 針對 ESM 的乾淨優雅打包器（Vite 在生產階段會使用它作為底層）。</li>
      <li><strong>Vite</strong> — 現代化、結合 esbuild（開發時）與 Rollup（生產時）的超快建構工具。</li>
    </ol>
  </section>
  <hr>
  <section>
    <h2>整體流程概述</h2>
    <p>目標：將程式碼轉換成瀏覽器能讀懂的格式，並減少載入檔案數量</p>
    <ul>
      <li><strong>第一步 — 語法轉換：</strong>把新 JS 語法（例如 <code>const</code>、箭頭函式、JSX、TypeScript）轉成舊 JS（ES5）。常見工具：Babel 或
        esbuild；打包工具（如 Webpack、Vite）會依賴編譯器先處理。</li>
      <li><strong>第二步 — 模組打包：</strong>把分散的檔案（.js, .css, images）合併成少數幾個檔案（例如
        <code>bundle.js</code>）。常見工具：Webpack 或 Rollup，這些工具在語法轉換後會將程式碼合併並優化。
      </li>
    </ul>
  </section>
  <hr>
  <section>
    <h2>關係與分工</h2>
    <table border="1" cellpadding="6" cellspacing="0">
      <thead>
        <tr>
          <th>階段</th>
          <th>核心工具</th>
          <th>協作工具（底層）</th>
          <th>關係描述</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>開發 (Dev)</td>
          <td>Vite（開發伺服器）</td>
          <td>esbuild</td>
          <td>Vite 利用 esbuild 的超快速度處理與轉換程式碼，達成幾乎即時的熱重載（hot-reload）。</td>
        </tr>
        <tr>
          <td>生產 (Build)</td>
          <td>Vite（build 命令）</td>
          <td>Rollup</td>
          <td>Vite 使用 Rollup 進行最終的生產打包，以達到更優化的 tree-shaking 與更小、更乾淨的輸出檔案。</td>
        </tr>
        <tr>
          <td>輔助</td>
          <td>Vite</td>
          <td>Babel</td>
          <td>若 esbuild 不支援某些特殊語法（例如實驗性語法或針對老舊瀏覽器），Vite 可透過 Plugin 搭配 Babel 輔助處理。</td>
        </tr>
      </tbody>
    </table>
  </section>
  <hr>
  <section>
    <h2>ECMAScript 與實作</h2>
    <p>
      <strong>ECMAScript（簡稱 ES）</strong> 是一種標準，不是程式語言。<br>
      <strong>JavaScript</strong> 是 ECMAScript 的一種實作，實現了 ECMAScript 標準並在瀏覽器中提供瀏覽器特有的 API（例如 DOM API）。<br>
      <strong>Node.js</strong> 也是 ECMAScript 的一種實作，實現了 ECMAScript 標準並提供 Node.js 的 API（例如 <code>fs</code> 模組）。
    </p>

    <p>以「汽車」類比：</p>
    <ul>
      <li>ECMAScript = 汽車設計圖標準</li>
      <li>JavaScript = Toyota 根據設計圖製造的車</li>
      <li>Node.js = Tesla 根據同樣設計圖，但改成電動車版本</li>
    </ul>
  </section>
  <hr>
  <h2>Buffer 是什麼？</h2>
  <ul>
    <li><strong>Buffer</strong> 是 Node.js 用來處理<strong>二進位資料</strong>的類別。</li>
    <li>在 JavaScript 裡，字串是以 UTF-16 編碼的，而 Buffer 則是以<strong>位元組（byte）</strong>為單位來儲存資料。</li>
    <li>Buffer 可以用來處理檔案讀寫、網路傳輸等需要操作二進位資料的情況。</li>
  </ul>

  <hr>

  <h2>Unicode 與 UTF-16 的關係</h2>
  <ul>
    <li><strong>Unicode</strong> 是一個<strong>字元編碼標準</strong>，為全球所有文字和符號分配「唯一的編碼」。</li>
    <li><strong>UTF-16</strong> 是「實現 Unicode」的一種<strong>具體編碼方式</strong>。</li>
  </ul>

  <hr>

  <h1>電腦編碼原理（ASCII、Unicode、UTF 系列）</h1>

  <h3>一、電腦只能看懂「數字（位元）」</h3>
  <p>對電腦而言，世界只有 0 和 1。字母、漢字、符號都要先「變成數字」，然後再「變成位元」才能儲存或顯示。</p>
  <blockquote>例如：A → 65 → 01000001（二進位）</blockquote>

  <h3>二、最早只有 ASCII（美國標準）</h3>
  <p>這套編碼叫 ASCII，只用 1 byte (8 bits)，可表示 0~127 共 128 個符號。只夠表示英文字母、數字與基本符號。</p>
  <table border="1" cellpadding="6" cellspacing="0">
    <thead>
      <tr>
        <th>字元</th>
        <th>十進位數字</th>
        <th>二進位</th>
        <th>位元組數</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>A</td>
        <td>65</td>
        <td>01000001</td>
        <td>1 byte</td>
      </tr>
      <tr>
        <td>B</td>
        <td>66</td>
        <td>01000010</td>
        <td>1 byte</td>
      </tr>
      <tr>
        <td>a</td>
        <td>97</td>
        <td>01100001</td>
        <td>1 byte</td>
      </tr>
    </tbody>
  </table>

  <h3>三、問題：那中文、日文、希伯來文怎辦？</h3>
  <p>各國自己發明不同的編碼（如 Big5、Shift-JIS、GB2312），導致不同地區的同一組數字會代表不同的字，造成全球混亂。</p>

  <h3>四、Unicode 的出現：統一編號系統</h3>
  <p>Unicode 的目標是：全世界所有文字，都有一個「全球唯一的代碼」 (Code Point)。</p>
  <p><strong>U+xxxx</strong> 是「抽象的字元代號」，不代表實際的位元資料，只是字元的全球身份證號碼。</p>
  <table border="1" cellpadding="6" cellspacing="0">
    <thead>
      <tr>
        <th>字元</th>
        <th>Unicode 碼點（Code Point）</th>
        <th>說明</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>A</td>
        <td>U+0041</td>
        <td>英文字母</td>
      </tr>
      <tr>
        <td>中</td>
        <td>U+4E2D</td>
        <td>中文字元</td>
      </tr>
      <tr>
        <td>😊</td>
        <td>U+1F60A</td>
        <td>Emoji 符號</td>
      </tr>
    </tbody>
  </table>

  <h3>五、UTF 系列的目的：把 Unicode「轉成」實際位元</h3>
  <p>UTF（Unicode Transformation Format）是把 Unicode 碼點轉成實際儲存或傳輸所需的 bytes。</p>
  <table border="1" cellpadding="6" cellspacing="0">
    <thead>
      <tr>
        <th>Unicode 碼點</th>
        <th>UTF-16 編碼 (Bytes)</th>
        <th>UTF-8 編碼 (Bytes)</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>U+0041 ('A')</td>
        <td>00 41 （2 bytes）</td>
        <td>41 （1 byte）</td>
      </tr>
    </tbody>
  </table>

  <h3>七、完整流程圖</h3>
  <ol>
    <li><strong>概念層：</strong> "A" → Unicode code point: U+0041 (全世界統一的代號)</li>
    <li><strong>編碼層：</strong>
      <ul>
        <li>UTF-8 → 0x41 → 01000001</li>
        <li>UTF-16 → 0x0041 → 00000000 01000001</li>
        <li>UTF-32 → 0x00000041→ 00000000 00000000 00000000 01000001</li>
      </ul>
    </li>
    <li><strong>顯示層：</strong> → 螢幕顯示 "A"</li>
  </ol>

  <hr>

  <h1>Node.js Buffer 實例分析</h1>

  <pre><code>let buf = Buffer.from('hello');
console.log(buf);
// 輸出：
// &lt;Buffer 68 65 6c 6c 6f&gt;
    </code></pre>

  <h3>二、發生了什麼？</h3>
  <ol>
    <li><code>'hello'</code>：JavaScript 字串，內部採用 UTF-16 編碼。</li>
    <li><code>Buffer.from('hello')</code>：Node.js 自動轉成 <strong>UTF-8 編碼的 bytes</strong>，建立 Buffer 物件。</li>
    <li><code>&lt;Buffer ... &gt;</code>：Node 以 <strong>十六進位（hexadecimal）格式</strong> 顯示每個位元組。</li>
  </ol>

  <h3>三、逐步對照分析 (UTF-8 編碼)</h3>
  <table border="1" cellpadding="6" cellspacing="0">
    <thead>
      <tr>
        <th>字元</th>
        <th>Unicode 碼點</th>
        <th>UTF-8 編碼 (十六進位)</th>
        <th>Buffer 內容</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>h</td>
        <td>U+0068</td>
        <td>68</td>
        <td>68</td>
      </tr>
      <tr>
        <td>e</td>
        <td>U+0065</td>
        <td>65</td>
        <td>65</td>
      </tr>
      <tr>
        <td>l</td>
        <td>U+006C</td>
        <td>6C</td>
        <td>6C</td>
      </tr>
      <tr>
        <td>l</td>
        <td>U+006C</td>
        <td>6C</td>
        <td>6C</td>
      </tr>
      <tr>
        <td>o</td>
        <td>U+006F</td>
        <td>6F</td>
        <td>6F</td>
      </tr>
    </tbody>
  </table>
  <p>結果：<code>&lt;Buffer 68 65 65 6c 6c 6f&gt;</code></p>

  <hr>

  <h2>UTF-8 編碼的位元組數</h2>

  <p><strong>總結：</strong> UTF-8 用 <strong>1～4 個 bytes</strong> 來表示一個 Unicode 字元，是變長（Variable-length）編碼。</p>

  <table border="1" cellpadding="6" cellspacing="0">
    <thead>
      <tr>
        <th>字元範圍 (Unicode 碼點)</th>
        <th>位元組數 (Bytes)</th>
        <th>常見範例</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>U+0000 ~ U+007F</td>
        <td>1 byte</td>
        <td>英文、數字 (與 ASCII 相同)</td>
      </tr>
      <tr>
        <td>U+0080 ~ U+07FF</td>
        <td>2 bytes</td>
        <td>拉丁擴充、希臘文等</td>
      </tr>
      <tr>
        <td>U+0800 ~ U+FFFF</td>
        <td>3 bytes</td>
        <td><strong>多數中文、日文、韓文</strong></td>
      </tr>
      <tr>
        <td>U+10000 ~ U+10FFFF</td>
        <td>4 bytes</td>
        <td><strong>Emoji</strong>、罕見字、特殊符號</td>
      </tr>
    </tbody>
  </table>
  <hr>
  <h2>🧩 一、什麼是「進程（Process）」</h2>
  <p><strong>進程（Process）</strong> 是：一個「正在執行中的程式」。</p>
  <p>每當你開啟一個應用程式（例如開啟 Chrome、Word、或計算機 app），作業系統就會建立一個「進程」來負責執行這個程式。</p>

  <h3>🔹進程的特性</h3>
  <ul>
    <li><strong>獨立性：</strong> 每個進程都有自己獨立的記憶體空間、資料、變數與系統資源。一個進程崩潰，不會直接影響其他進程。（例如 Chrome 當中的一個分頁當掉，其他分頁仍能運作）</li>
    <li><strong>系統資源分配單位：</strong> 作業系統分配記憶體、CPU 時間等資源給進程。</li>
    <li><strong>開銷較大：</strong> 建立、切換進程需要花費較多資源（例如記憶體、系統呼叫等）。</li>
  </ul>

  <h2>🧵 二、什麼是「線程（Thread）」</h2>
  <p><strong>線程（Thread）</strong> 是：進程中的「執行單位」。</p>
  <p>一個進程可以包含一條或多條線程，這些線程共享同一個進程的資源（記憶體、檔案描述符等），但每條線程有自己獨立的執行堆疊（stack）與計數器（program counter）。</p>

  <h3>🔹線程的特性</h3>
  <ul>
    <li><strong>輕量級（lightweight）：</strong> 線程的建立和切換比進程更快，因為它們共享相同的記憶體空間。</li>
    <li><strong>共享資源：</strong> 同一進程內的多個線程可以直接共享變數與資料。
      <blockquote>👉 這讓多線程能夠快速協作，但也可能產生<strong>競爭條件（race condition）與死鎖（deadlock）</strong>問題。</blockquote>
    </li>
    <li><strong>同時執行（併發）：</strong> 多條線程可以在多核心 CPU 上同時執行不同的任務，提升效能。</li>
  </ul>

  <h2>🧠 三、舉例說明</h2>
  <p>假設你打開一個「網頁瀏覽器」：</p>
  <ul>
    <li>每個開啟的瀏覽器視窗或分頁 = 一個「<strong>進程（Process）</strong>」</li>
    <li>每個分頁裡：
      <ul>
        <li>一條線程負責載入 HTML</li>
        <li>一條線程負責渲染畫面</li>
        <li>一條線程負責執行 JavaScript</li>
      </ul>
      → 這些都是「<strong>線程（Threads）</strong>」。
    </li>
  </ul>
  <hr>
  <h3>甚麼是 \r\n</h3>
  <p>當我們輸出「文字」時，像 <code>\r\n</code> 這種「跳脫序列（escape sequence）」並不是字面上的兩個字元，而是電腦在解析並執行對應動作（例如換行）。</p>
  <hr>
  <h2>一、Node.js 檔案寫入與 Windows 權限</h2>

  <pre><code>const fs = require('fs');
fs.writeFileSync('/hello.txt', 'Hello World');
// 執行結果：在磁盤根目錄下會產生一個 hello.txt 檔案，內容是 "Hello World"
    </code></pre>

  <h3>為什麼在 C 槽 (C:\) 根目錄通常沒有權限？</h3>
  <p>⚠️ Windows 為了保護系統安全，一般使用者（即使你是「電腦的主人」）預設不能直接寫入 <code>C:\</code> 根目錄。</p>
  <ul>
    <li>你仍然可以在自己的使用者資料夾（例如 <code>C:\Users\你的帳號\</code>）下自由建立與修改檔案。</li>
    <li>但像 <code>C:\</code>、<code>C:\Windows</code>、<code>C:\Program Files</code> 這些系統區域都是受保護的目錄。</li>
  </ul>

  <h3>如果堅持要在 C 槽根目錄寫入？</h3>
  <p>需要**以系統管理員模式執行 Node**：</p>
  <ol>
    <li>搜尋 PowerShell 或 CMD → 右鍵 → <strong>以系統管理員身分執行</strong>。</li>
    <li>再執行：<code>node your_script.js</code>。</li>
  </ol>
  <p>這時 Node 會繼承「Administrator」權限，因此程式碼如 <code>fs.writeFileSync('C:/hello.txt', 'hi!');</code> **會成功執行**。</p>
  <blockquote>📘 這是最直接、也最常見的解決方式。</blockquote>

  <hr>

  <h2>二、相對路徑的基準點</h2>
  <p>有一個很特別的事情：</p>
  <p><strong>Node.js fs 模組的相對路徑是相對於 執行 node 的位置，而不是相對於 js 檔案的位置。</strong></p>

  <hr>

  <h2>三、路徑分隔符 / 與 \ 的兼容性</h2>

  <h3>為什麼路徑 / 跟 \ 它們的表達意思不衝突？</h3>
  <p>在 Windows 上，正斜線 (<code>/</code>) 和反斜線 (<code>\</code>) 都能用來表示路徑。</p>
  <p>雖然理論上 Windows 系統「正確的分隔符」是反斜線 <code>\</code>，但現代作業系統與程式庫（像 Node.js、Python、PowerShell）都自動幫你把 <code>/</code> 轉成
    <code>\</code>，以達到跨系統相容。
  </p>

  <h3>背景知識：路徑分隔符的歷史</h3>
  <table border="1" cellpadding="6" cellspacing="0">
    <thead>
      <tr>
        <th>系統</th>
        <th>路徑分隔符</th>
        <th>範例</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Unix / Linux / macOS</td>
        <td>正斜線 <code>/</code></td>
        <td><code>/usr/local/bin</code></td>
      </tr>
      <tr>
        <td>Windows</td>
        <td>反斜線 <code>\</code></td>
        <td><code>C:\Program Files\Node</code></td>
      </tr>
    </tbody>
  </table>

  <h3>Node.js 怎麼處理的？</h3>
  <p>當你在 Node.js 中使用：</p>
  <pre><code>fs.writeFileSync('C:/hello.txt', 'hi');</code></pre>
  <p>Node.js 在 Windows 上實際執行時，會幫你轉成：<code>C:\hello.txt</code></p>
  <p>✅ 所以你不需要手動改成反斜線。</p>

  <h3>在命令列（PowerShell / CMD）中也能用 / 的原因</h3>
  <p>Windows 的命令列工具（像 PowerShell, CMD, Explorer）在 2000 年代之後為了相容性與開發者方便，都內建了「路徑容錯機制」。</p>
  <blockquote>🔸 例如：<code>cd C:/Windows/System32</code> 會被系統自動轉譯成：<code>cd C:\Windows\System32</code></blockquote>
  <p>這樣一來，你從 macOS 或 Linux 的開發習慣轉過來，也能照常使用 <code>/</code>。</p>

  <hr>

  <h2>四、__dirname 絕對路徑變數</h2>
  <p><strong><code>__dirname</code></strong>：它代表，此文件所在的目錄路徑，而且是<strong>絕對路徑</strong>，直到文件夾結束。</p>
  <hr>
  <h2>path.resolve() 行為分析</h2>

  <p><strong>程式碼：</strong> <code>console.log('Current file path:', path.resolve(__filename, '/index.html'));</code>
  </p>

  <h3>為甚麼這樣變成跟目錄了？</h3>

  <p>問題核心在於 <code>path.resolve()</code> 的運作邏輯，它會從<strong>右到左</strong>處理參數，直到遇到一個「絕對路徑」為止。</p>

  <ul>
    <li><code>__filename</code>：這是當前檔案的<strong>絕對路徑</strong>（例如 <code>/Users/user/project/file.js</code>）。</li>
    <li><code>/index.html</code>：這是一個以 <code>/</code> 開頭的**絕對路徑**。</li>
  </ul>

  <p>當 <code>path.resolve()</code> 處理到第二個參數 <code>/index.html</code> 時：</p>
  <blockquote>
    它是一個絕對路徑（以 <code>/</code> 開頭），所以 <code>path.resolve()</code> 會將它當成「根」來處理，並<strong>忽略</strong>它前面所有的路徑部分（包括
    <code>__filename</code>）。
  </blockquote>

  <p>因此，結果會直接是作業系統的根目錄下的 <code>index.html</code>：</p>
  <p><strong>輸出結果：</strong> <code>/index.html</code></p>
  <hr>
  <h2>子網路遮罩計算 (Subnet Mask)</h2>

  <p>子網路遮罩用於將 IP 位址分為「網路位址 (Network Address)」和「主機位址 (Host Address)」兩部分。</p>
  <p>計算可用主機數量的公式：<strong>2^n - 2</strong>

  <h3>範例一：C 類網路遮罩</h3>
  <table border="1" cellpadding="5" cellspacing="0">
    <thead>
      <tr>
        <th>項目</th>
        <th>數值</th>
        <th>說明</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>IPv4 位址</td>
        <td>192.168.0.12</td>
        <td></td>
      </tr>
      <tr>
        <td>子網路遮罩</td>
        <td>255.255.255.0</td>
        <td></td>
      </tr>
      <tr>
        <td>子網路遮罩 (二進制)</td>
        <td>11111111.11111111.11111111.<strong>00000000</strong></td>
        <td><strong>前面 24 個 1</strong> (網路位址)，<strong>後面 8 個 0</strong> (主機位址，$n=8$)</td>
      </tr>
      <tr>
        <td>總位址數</td>
        <td>$2^8 = 256$</td>
        <td></td>
      </tr>
      <tr>
        <td>可用主機數量</td>
        <td>$256 - 2 = 254$</td>
        <td>扣除網路位址 (192.168.0.0) 和廣播位址 (192.168.0.255)</td>
      </tr>
      <tr>
        <td>CIDR 表示法</td>
        <td>/24</td>
        <td>表示子網路遮罩有 24 個 1</td>
      </tr>
      <tr>
        <td>網路/CIDR</td>
        <td>192.168.0.0/24</td>
        <td></td>
      </tr>
    </tbody>
  </table>

  <h3>範例二：A 類網路遮罩</h3>
  <table border="1" cellpadding="5" cellspacing="0">
    <thead>
      <tr>
        <th>項目</th>
        <th>數值</th>
        <th>說明</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>IPv4 位址</td>
        <td>10.0.0.23</td>
        <td></td>
      </tr>
      <tr>
        <td>子網路遮罩</td>
        <td>255.0.0.0</td>
        <td></td>
      </tr>
      <tr>
        <td>子網路遮罩 (二進制)</td>
        <td>11111111.<strong>00000000.00000000.00000000</strong></td>
        <td><strong>前面 8 個 1</strong> (網路位址)，<strong>後面 24 個 0</strong> (主機位址，$n=24$)</td>
      </tr>
      <tr>
        <td>總位址數</td>
        <td>$2^{24} = 16777216$</td>
        <td></td>
      </tr>
      <tr>
        <td>可用主機數量</td>
        <td>$16777216 - 2 = 16777214$</td>
        <td>扣除網路位址 (10.0.0.0) 和廣播位址 (10.255.255.255)</td>
      </tr>
      <tr>
        <td>可用主機範圍</td>
        <td>10.0.0.1 ～ 10.255.255.254</td>
        <td></td>
      </tr>
      <tr>
        <td>CIDR 表示法</td>
        <td>/8</td>
        <td>表示子網路遮罩有 8 個 1</td>
      </tr>
      <tr>
        <td>網路/CIDR</td>
        <td>10.0.0.0/8</td>
        <td></td>
      </tr>
    </tbody>
  </table>
  <hr>
  <h2>一、一台主機可以有多個不同端口處理不同事情嗎？</h2>
  <p><strong>答案：✅ 可以。</strong></p>

  <p>一台主機（Host）可以同時開啟多個不同的端口（Port），處理不同的服務或應用程式。</p>

  <h3>🧠 基本原理說明</h3>
  <ul>
    <li>每台主機在網路中都有一個「IP 位址」，代表主機整體。</li>
    <li>我們用「<strong>Port（埠號）</strong>」來區分同一主機上不同的網路應用。</li>
    <li><strong>IP + Port 就能唯一識別主機上的某個應用或服務</strong></li>
  </ul>

  <h3>📦 範例說明 (主機 IP: 192.168.0.10)</h3>
  <table border="1">
    <thead>
      <tr>
        <th>服務類型</th>
        <th>Port</th>
        <th>通訊協定</th>
        <th>說明</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>HTTP 網頁服務</td>
        <td>80</td>
        <td>TCP</td>
        <td>網站伺服器 (ex: Apache, Nginx)</td>
      </tr>
      <tr>
        <td>HTTPS 安全網頁</td>
        <td>443</td>
        <td>TCP</td>
        <td>使用 SSL/TLS 的安全網站</td>
      </tr>
      <tr>
        <td>SSH 遠端登入</td>
        <td>22</td>
        <td>TCP</td>
        <td>系統管理員登入用</td>
      </tr>
      <tr>
        <td>FTP 檔案傳輸</td>
        <td>21</td>
        <td>TCP</td>
        <td>傳送與接收檔案</td>
      </tr>
      <tr>
        <td>DNS 查詢服務</td>
        <td>53</td>
        <td>UDP/TCP</td>
        <td>網域名稱解析</td>
      </tr>
      <tr>
        <td>自訂應用程式</td>
        <td>3000</td>
        <td>TCP</td>
        <td>例如你自己寫的 Node.js 伺服器</td>
      </tr>
    </tbody>
  </table>
  <p><strong>總結：</strong>同一台主機上，可以同時運行多個不同的程式，只要各自使用不同的 Port 就不會衝突。</p>

  <hr>

  <h2>二、一個應用程序可以同時使用多個 Port 嗎？</h2>

  <p><strong>答案：✅ 可以。</strong></p>

  <p>一個應用程序（Process）可以同時監聽多個不同的端口（Port）。</p>

  <h3>例 1：Web 伺服器 (Nginx/Apache)</h3>
  <p>像 Nginx 或 Apache 這樣一個應用程式，可能同時監聽多個埠：</p>
  <table border="1">
    <thead>
      <tr>
        <th>埠號</th>
        <th>功能</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>80</td>
        <td>HTTP（未加密連線）</td>
      </tr>
      <tr>
        <td>443</td>
        <td>HTTPS（加密連線）</td>
      </tr>
    </tbody>
  </table>
  <p>➡️ 雖然是同一個 Web 伺服器進程（process），但同時處理兩個 Port 的流量。</p>

  <h3>例 2：Node.js 範例（同時監聽 8080 和 5000）</h3>
  <pre>
const http = require('http');

const server1 = http.createServer((req, res) => {
    res.end('Port 8080 - Web Interface');
});
server1.listen(8080); // 監聽 Port 8080

const server2 = http.createServer((req, res) => {
    res.end('Port 5000 - API Interface');
});
server2.listen(5000); // 監聽 Port 5000
    </pre>

  <hr>

  <h2>三、執行程式時的 PID 是什麼？</h2>

  <h3>什麼是 PID？</h3>
  <p><strong>PID 是英文 Process ID（進程 ID）的縮寫。</strong></p>
  <p>它是作業系統為每一個「正在執行的程式」分配的<strong>唯一編號</strong>。</p>

  <h3>🔑 核心概念對比</h3>
  <table border="1">
    <thead>
      <tr>
        <th>術語</th>
        <th>含義</th>
        <th>作用</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Process（進程）</strong></td>
        <td>程式實際執行實體</td>
        <td>一個應用運作中的狀態</td>
      </tr>
      <tr>
        <td><strong>PID</strong></td>
        <td>Process ID，進程的唯一編號</td>
        <td>作業系統用來追蹤、管理和控制該執行程式的編號</td>
      </tr>
      <tr>
        <td><strong>Port（端口）</strong></td>
        <td>網路服務的通訊入口</td>
        <td>區分同一主機上的不同網路服務（如：3000, 80, 443 等）</td>
      </tr>
      <tr>
        <td><strong>Thread（執行緒）</strong></td>
        <td>同一進程內的多任務執行路線</td>
        <td>同一應用程式內，用來處理多個任務的最小執行單位</td>
      </tr>
    </tbody>
  </table>
  <hr>
</body>

</html>