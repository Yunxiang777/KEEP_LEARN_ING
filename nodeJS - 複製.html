const fs = require('fs');
fs.writeFileSync('/hello.txt', 'Hello World');
/ => 磁盤根目錄下會產生一個 hello.txt 檔案，內容是 "Hello World"
但如果是C槽，那通常沒有權限，為甚麼?
⚠️ Windows 為了保護系統安全，
一般使用者（即使你是「電腦的主人」）預設不能直接寫入 C:\ 根目錄。
你仍然可以在自己的使用者資料夾（例如 C:\Users\你的帳號\）下自由建立與修改檔案，
但像 C:\、C:\Windows、C:\Program Files 這些系統區域都是受保護的目錄。
那如果我堅持要在C寫呢?
以系統管理員模式執行 Node

搜尋 PowerShell 或 CMD → 右鍵 → 以系統管理員身分執行

再執行：

node your_script.js


這時 Node 會繼承「Administrator」權限。
因此程式內的：

fs.writeFileSync('C:/hello.txt', 'hi!');


✅ 會成功執行。

📘 這是最直接、也最常見的方式。

有一個很特別的事情
NODE JS fs，他相對路徑是相對於 執行 node 的位置，而不是相對於 js 檔案的位置

為甚麼路徑 / 跟 \ 它路徑表達意思不衝突?
在 Windows 上，/ 和 \ 都能用來表示路徑。
雖然理論上「正確的分隔符」是 反斜線 \，
但現代作業系統與程式庫（像 Node.js、Python、PowerShell）
都自動幫你把 / 轉成 \

背景知識：路徑分隔符的歷史
系統 路徑分隔符 範例
Unix / Linux / macOS / /usr/local/bin
Windows \ C:\Program Files\Node

Node.js 怎麼處理的？
fs.writeFileSync('C:/hello.txt', 'hi');
Node.js 在 Windows 上實際執行時，會幫你轉成：

txt
複製程式碼
C:\hello.txt
✅ 所以你不需要手動改成反斜線。

在命令列（PowerShell / CMD）中也能用 / 的原因

Windows 的命令列工具（像 PowerShell、CMD、Explorer）
在 2000 年代之後為了相容性與開發者方便，
都內建了「路徑容錯機制」：

🔸 例如：

cd C:/Windows/System32


會被系統自動轉譯成：

cd C:\Windows\System32


這樣一來，你從 macOS 或 Linux 的開發習慣轉過來，也能照常使用 /。

__dirname，它代表，此文件所在的目錄路徑，而且是絕對路徑，直到文件夾結束